<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Appel vidéo - {{ call.conversation_name }} - EduMath-Info</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">
    <style>
        :root {
            --primary-color: #6366f1;
            --secondary-color: #8b5cf6;
            --accent-color: #06b6d4;
            --math-color: #f59e0b;
            --info-color: #10b981;
            --dark-color: #1e293b;
            --light-color: #f8fafc;
            --text-color: #334155;
            --text-light: #64748b;
            --gradient-primary: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        body {
            background: linear-gradient(135deg, #1e293b 0%, #334155 50%, #475569 100%);
            color: white;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
        }

        .video-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .videos-grid {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            padding: 15px;
        }

        .video-wrapper {
            position: relative;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: var(--shadow-lg);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .video-wrapper video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-label {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 25px;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
        }

        .local-video {
            position: fixed;
            bottom: 100px;
            right: 20px;
            width: 250px;
            height: 180px;
            border: 3px solid var(--primary-color);
            border-radius: 15px;
            z-index: 1000;
            box-shadow: var(--shadow-xl);
            backdrop-filter: blur(10px);
        }

        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            display: flex;
            justify-content: center;
            gap: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-btn {
            width: 65px;
            height: 65px;
            border-radius: 50%;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-md);
        }

        .control-btn:hover {
            transform: scale(1.1);
            box-shadow: var(--shadow-lg);
        }

        .control-btn.mute {
            background: var(--info-color);
            color: white;
        }

        .control-btn.mute.active {
            background: #dc3545;
        }

        .control-btn.screen {
            background: #6c757d;
            color: white;
        }

        .control-btn.end {
            background: #dc3545;
            color: white;
        }

        .call-info {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 1001;
            background: rgba(30, 41, 59, 0.9);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .call-duration {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .participant-count {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .videos-grid {
                grid-template-columns: 1fr;
                gap: 10px;
                padding: 10px;
            }

            .local-video {
                width: 150px;
                height: 110px;
                bottom: 90px;
                right: 10px;
            }

            .controls {
                padding: 15px;
                gap: 15px;
            }

            .control-btn {
                width: 55px;
                height: 55px;
                font-size: 1.3rem;
            }

            .call-info {
                top: 10px;
                left: 10px;
                right: 10px;
                padding: 12px 15px;
            }
        }

        @media (max-width: 480px) {
            .local-video {
                width: 120px;
                height: 90px;
                bottom: 85px;
                right: 5px;
            }

            .controls {
                padding: 10px;
                gap: 10px;
            }

            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 1.2rem;
            }

            .call-duration {
                font-size: 1rem;
            }
        }

        /* Animations */
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .recording-indicator {
            animation: pulse 1.5s infinite;
        }

        /* Screen share indicator */
        .screen-share-indicator {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255, 193, 7, 0.9);
            color: #000;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="call-info">
        <h5 class="mb-0">
            <i class="bi bi-camera-video-fill me-2"></i> {{ call.conversation_name or 'Appel vidéo' }}
        </h5>
        <div class="d-flex align-items-center gap-3 mt-1">
            <span class="call-duration" id="callDuration">00:00</span>
            <span class="participant-count">
                <i class="bi bi-people"></i> <span id="participantCount">1</span> participant(s)
            </span>
        </div>
    </div>

    <div class="video-container">
        <div class="videos-grid" id="videosGrid">
            <!-- Remote videos will be added here -->
        </div>

        <div class="video-wrapper local-video">
            <video id="localVideo" autoplay muted></video>
            <div class="video-label">Vous</div>
        </div>

        <div class="controls">
            <button class="control-btn mute" id="toggleAudio" title="Activer/Désactiver le micro">
                <i class="bi bi-mic-fill"></i>
            </button>
            <button class="control-btn mute" id="toggleVideo" title="Activer/Désactiver la caméra">
                <i class="bi bi-camera-video-fill"></i>
            </button>
            <button class="control-btn screen" id="shareScreen" title="Partager l'écran">
                <i class="bi bi-display"></i>
            </button>
            <button class="control-btn end" id="endCall" title="Quitter l'appel">
                <i class="bi bi-telephone-x-fill"></i>
            </button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        let localStream = null;
        let ws = null;
        let peerConnections = {};
        let audioEnabled = true;
        let videoEnabled = true;
        let screenSharing = false;
        
        const callId = {{ call.id }};
        const userId = {{ user.id }};
        const userName = "{{ user.first_name }}";

        // ICE servers configuration
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // Initialize media
        async function initializeMedia() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: 'user'
                    },
                    audio: { 
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                document.getElementById('localVideo').srcObject = localStream;
                
                // Connect WebSocket
                connectWebSocket();
                
                console.log('Media initialized successfully');
            } catch (error) {
                console.error('Error accessing media devices:', error);
                showError('Erreur d\'accès à la caméra/micro. Vérifiez les permissions.');
            }
        }

        function connectWebSocket() {
            ws = new WebSocket(`ws://${window.location.host}/ws/call/${callId}/${userId}`);
            
            ws.onopen = () => {
                console.log('WebSocket connected');
                // Announce presence
                sendSignal({ type: 'join', userName: userName });
            };
            
            ws.onmessage = async (event) => {
                const message = JSON.parse(event.data);
                await handleSignal(message);
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                showError('Erreur de connexion');
            };
            
            ws.onclose = () => {
                console.log('WebSocket closed');
                showError('Connexion perdue');
            };
        }

        async function handleSignal(message) {
            const { from, type, data } = message;
            
            if (from === userId) return; // Ignore own messages
            
            switch (type) {
                case 'join':
                    await createPeerConnection(from, true);
                    updateParticipantCount();
                    break;
                    
                case 'offer':
                    await handleOffer(from, data);
                    break;
                    
                case 'answer':
                    await handleAnswer(from, data);
                    break;
                    
                case 'ice-candidate':
                    await handleIceCandidate(from, data);
                    break;
                    
                case 'user_left':
                    handleUserLeft(from);
                    updateParticipantCount();
                    break;
            }
        }

        async function createPeerConnection(peerId, isInitiator) {
            const pc = new RTCPeerConnection(configuration);
            peerConnections[peerId] = pc;
            
            // Add local tracks
            localStream.getTracks().forEach(track => {
                pc.addTrack(track, localStream);
            });
            
            // Handle incoming tracks
            pc.ontrack = (event) => {
                addRemoteVideo(peerId, event.streams[0]);
            };
            
            // Handle ICE candidates
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    sendSignal({
                        type: 'ice-candidate',
                        data: event.candidate
                    });
                }
            };
            
            // Handle connection state changes
            pc.onconnectionstatechange = () => {
                console.log(`Connection state with ${peerId}: ${pc.connectionState}`);
            };
            
            // Create offer if initiator
            if (isInitiator) {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                sendSignal({
                    type: 'offer',
                    data: offer
                });
            }
            
            return pc;
        }

        async function handleOffer(peerId, offer) {
            const pc = await createPeerConnection(peerId, false);
            await pc.setRemoteDescription(new RTCSessionDescription(offer));
            
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            
            sendSignal({
                type: 'answer',
                data: answer
            });
        }

        async function handleAnswer(peerId, answer) {
            const pc = peerConnections[peerId];
            if (pc) {
                await pc.setRemoteDescription(new RTCSessionDescription(answer));
            }
        }

        async function handleIceCandidate(peerId, candidate) {
            const pc = peerConnections[peerId];
            if (pc) {
                await pc.addIceCandidate(new RTCIceCandidate(candidate));
            }
        }

        function addRemoteVideo(peerId, stream) {
            const grid = document.getElementById('videosGrid');
            
            // Remove existing video if any
            const existing = document.getElementById(`video-${peerId}`);
            if (existing) {
                existing.remove();
            }
            
            const wrapper = document.createElement('div');
            wrapper.className = 'video-wrapper';
            wrapper.id = `video-${peerId}`;
            
            const video = document.createElement('video');
            video.srcObject = stream;
            video.autoplay = true;
            video.playsinline = true;
            
            const label = document.createElement('div');
            label.className = 'video-label';
            label.textContent = `Participant ${peerId}`;
            
            wrapper.appendChild(video);
            wrapper.appendChild(label);
            grid.appendChild(wrapper);
        }

        function handleUserLeft(peerId) {
            const video = document.getElementById(`video-${peerId}`);
            if (video) {
                video.remove();
            }
            
            if (peerConnections[peerId]) {
                peerConnections[peerId].close();
                delete peerConnections[peerId];
            }
        }

        function sendSignal(signal) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(signal));
            }
        }

        function updateParticipantCount() {
            const count = Object.keys(peerConnections).length + 1; // +1 for local
            document.getElementById('participantCount').textContent = count;
        }

        function showError(message) {
            // Create a temporary error notification
            const errorDiv = document.createElement('div');
            errorDiv.className = 'alert alert-danger alert-dismissible fade show position-fixed top-0 start-50 translate-middle-x mt-3';
            errorDiv.style.zIndex = '9999';
            errorDiv.innerHTML = `
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            document.body.appendChild(errorDiv);
            
            setTimeout(() => {
                errorDiv.remove();
            }, 5000);
        }

        // Controls
        document.getElementById('toggleAudio').addEventListener('click', () => {
            audioEnabled = !audioEnabled;
            localStream.getAudioTracks()[0].enabled = audioEnabled;
            
            const btn = document.getElementById('toggleAudio');
            btn.classList.toggle('active');
            btn.querySelector('i').className = audioEnabled ? 'bi bi-mic-fill' : 'bi bi-mic-mute-fill';
            
            // Update all peer connections
            Object.values(peerConnections).forEach(pc => {
                const sender = pc.getSenders().find(s => s.track && s.track.kind === 'audio');
                if (sender) {
                    sender.track.enabled = audioEnabled;
                }
            });
        });

        document.getElementById('toggleVideo').addEventListener('click', () => {
            videoEnabled = !videoEnabled;
            localStream.getVideoTracks()[0].enabled = videoEnabled;
            
            const btn = document.getElementById('toggleVideo');
            btn.classList.toggle('active');
            btn.querySelector('i').className = videoEnabled ? 'bi bi-camera-video-fill' : 'bi bi-camera-video-off-fill';
            
            // Update all peer connections
            Object.values(peerConnections).forEach(pc => {
                const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
                if (sender) {
                    sender.track.enabled = videoEnabled;
                }
            });
        });

        document.getElementById('shareScreen').addEventListener('click', async () => {
            try {
                if (!screenSharing) {
                    const screenStream = await navigator.mediaDevices.getDisplayMedia({ 
                        video: true,
                        audio: true 
                    });
                    
                    const screenTrack = screenStream.getVideoTracks()[0];
                    const videoTrack = localStream.getVideoTracks()[0];
                    
                    // Replace video track in all peer connections
                    Object.values(peerConnections).forEach(pc => {
                        const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
                        if (sender) {
                            sender.replaceTrack(screenTrack);
                        }
                    });
                    
                    // Update local video
                    const localVideo = document.getElementById('localVideo');
                    localVideo.srcObject = screenStream;
                    
                    // Add screen share indicator
                    const indicator = document.createElement('div');
                    indicator.className = 'screen-share-indicator';
                    indicator.innerHTML = '<i class="bi bi-display"></i> Partage d\'écran';
                    document.querySelector('.local-video').appendChild(indicator);
                    
                    screenSharing = true;
                    
                    screenTrack.onended = () => {
                        // Restore camera when screen sharing stops
                        Object.values(peerConnections).forEach(pc => {
                            const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
                            if (sender && videoTrack) {
                                sender.replaceTrack(videoTrack);
                            }
                        });
                        
                        localVideo.srcObject = localStream;
                        indicator.remove();
                        screenSharing = false;
                    };
                } else {
                    // Stop screen sharing
                    const videoTrack = localStream.getVideoTracks()[0];
                    Object.values(peerConnections).forEach(pc => {
                        const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
                        if (sender && videoTrack) {
                            sender.replaceTrack(videoTrack);
                        }
                    });
                    
                    document.getElementById('localVideo').srcObject = localStream;
                    document.querySelector('.screen-share-indicator')?.remove();
                    screenSharing = false;
                }
            } catch (error) {
                console.error('Error sharing screen:', error);
                showError('Erreur lors du partage d\'écran');
            }
        });

        document.getElementById('endCall').addEventListener('click', async () => {
            if (confirm('Êtes-vous sûr de vouloir quitter l\'appel?')) {
                // Close all peer connections
                Object.values(peerConnections).forEach(pc => {
                    pc.close();
                });
                
                // Stop local stream
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                }
                
                // Close WebSocket
                if (ws) {
                    ws.close();
                }
                
                // End call on server
                const formData = new FormData();
                formData.append('call_id', callId);
                await fetch('/end_call', { method: 'POST', body: formData });
                
                window.close();
            }
        });

        // Call duration timer
        let startTime = Date.now();
        setInterval(() => {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            document.getElementById('callDuration').textContent = `${minutes}:${seconds}`;
        }, 1000);

        // Handle page unload
        window.addEventListener('beforeunload', (e) => {
            if (Object.keys(peerConnections).length > 0) {
                e.preventDefault();
                e.returnValue = '';
            }
        });

        // Initialize on load
        initializeMedia();
    </script>
</body>
</html>